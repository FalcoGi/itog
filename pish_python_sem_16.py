# -*- coding: utf-8 -*-
"""PISH_Python_sem_16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/108wwFl9wnb9EfiGw3wGPBu9ctAp2nq3M
"""

# Решение: Настольное приложение для менеджеров интернет-магазина

## Структура проекта

```
internet_shop_manager/
│
├── models/                  # Модули с классами данных
│   ├── __init__.py
│   ├── customer.py          # Класс клиента
│   ├── product.py           # Класс товара
│   └── order.py             # Класс заказа
│
├── db/                      # Работа с данными
│   ├── __init__.py
│   ├── database.py          # Основной класс работы с БД
│   ├── csv_handler.py       # Импорт/экспорт CSV
│   └── json_handler.py      # Импорт/экспорт JSON
│
├── gui/                     # Графический интерфейс
│   ├── __init__.py
│   ├── main_window.py       # Главное окно
│   ├── customer_window.py   # Окно работы с клиентами
│   ├── order_window.py      # Окно работы с заказами
│   └── analysis_window.py   # Окно анализа данных
│
├── analysis/                # Анализ и визуализация
│   ├── __init__.py
│   ├── visualizer.py        # Визуализация данных
│   └── analyzer.py          # Анализ данных
│
├── utils/                   # Вспомогательные модули
│   ├── __init__.py
│   ├── validators.py        # Валидация данных
│   └── helpers.py           # Вспомогательные функции
│
├── tests/                   # Тесты
│   ├── __init__.py
│   ├── test_models.py
│   └── test_analysis.py
│
├── docs/                    # Документация
│
├── main.py                  # Точка входа
└── README.md
```

## Реализация основных модулей

### 1. models/customer.py

import re
from dataclasses import dataclass, field
from typing import List, Optional
from datetime import datetime


@dataclass
class Customer:
    """Класс для представления клиента интернет-магазина.

    Attributes
    ----------
    customer_id : int
        Уникальный идентификатор клиента
    name : str
        Полное имя клиента
    email : str
        Электронная почта клиента
    phone : str
        Номер телефона клиента
    address : str
        Адрес клиента
    registration_date : datetime
        Дата регистрации клиента
    """

    customer_id: int
    name: str
    email: str
    phone: str
    address: str
    registration_date: datetime = field(default_factory=datetime.now)

    def __post_init__(self):
        """Валидация данных после инициализации."""
        if not self._validate_email():
            raise ValueError("Некорректный email")
        if not self._validate_phone():
            raise ValueError("Некорректный номер телефона")

    def _validate_email(self) -> bool:
        """Проверка валидности email с помощью регулярного выражения.

        Returns
        -------
        bool
            True если email валиден, иначе False
        """
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, self.email) is not None

    def _validate_phone(self) -> bool:
        """Проверка валидности номера телефона с помощью регулярного выражения.

        Returns
        -------
        bool
            True если номер телефона валиден, иначе False
        """
        pattern = r'^\+?[1-9]\d{1,14}$'  # E.164 format
        return re.match(pattern, self.phone) is not None

    def to_dict(self) -> dict:
        """Преобразование объекта клиента в словарь.

        Returns
        -------
        dict
            Словарь с атрибутами клиента
        """
        return {
            'customer_id': self.customer_id,
            'name': self.name,
            'email': self.email,
            'phone': self.phone,
            'address': self.address,
            'registration_date': self.registration_date.isoformat()
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'Customer':
        """Создание объекта клиента из словаря.

        Parameters
        ----------
        data : dict
            Словарь с атрибутами клиента

        Returns
        -------
        Customer
            Объект класса Customer
        """
        return cls(
            customer_id=data['customer_id'],
            name=data['name'],
            email=data['email'],
            phone=data['phone'],
            address=data['address'],
            registration_date=datetime.fromisoformat(data['registration_date'])
        )


### 2. db/database.py


import sqlite3
from typing import List, Optional, Dict, Any
from pathlib import Path
from datetime import datetime
from ..models.customer import Customer
from ..models.product import Product
from ..models.order import Order


class Database:
    """Класс для работы с базой данных SQLite.

    Attributes
    ----------
    db_path : Path
        Путь к файлу базы данных
    """

    def __init__(self, db_path: str = 'shop.db'):
        """Инициализация подключения к базе данных.

        Parameters
        ----------
        db_path : str, optional
            Путь к файлу базы данных, по умолчанию 'shop.db'
        """
        self.db_path = Path(db_path)
        self._init_db()

    def _init_db(self) -> None:
        """Инициализация таблиц в базе данных при первом запуске."""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # Создание таблицы клиентов
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS customers (
                    customer_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    email TEXT NOT NULL UNIQUE,
                    phone TEXT NOT NULL,
                    address TEXT NOT NULL,
                    registration_date TEXT NOT NULL
                )
            ''')

            # Создание таблицы товаров
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS products (
                    product_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    price REAL NOT NULL,
                    description TEXT,
                    stock INTEGER NOT NULL
                )
            ''')

            # Создание таблицы заказов
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS orders (
                    order_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    customer_id INTEGER NOT NULL,
                    order_date TEXT NOT NULL,
                    status TEXT NOT NULL,
                    total_amount REAL NOT NULL,
                    FOREIGN KEY (customer_id) REFERENCES customers (customer_id)
                )
            ''')

            # Создание таблицы связей заказов и товаров
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS order_items (
                    order_item_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_id INTEGER NOT NULL,
                    product_id INTEGER NOT NULL,
                    quantity INTEGER NOT NULL,
                    price_per_unit REAL NOT NULL,
                    FOREIGN KEY (order_id) REFERENCES orders (order_id),
                    FOREIGN KEY (product_id) REFERENCES products (product_id)
                )
            ''')

            conn.commit()

    # Методы для работы с клиентами
    def add_customer(self, customer: Customer) -> int:
        """Добавление нового клиента в базу данных.

        Parameters
        ----------
        customer : Customer
            Объект клиента для добавления

        Returns
        -------
        int
            ID добавленного клиента
        """
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO customers (name, email, phone, address, registration_date)
                VALUES (?, ?, ?, ?, ?)
            ''', (
                customer.name,
                customer.email,
                customer.phone,
                customer.address,
                customer.registration_date.isoformat()
            ))
            customer_id = cursor.lastrowid
            conn.commit()
        return customer_id

    # Другие методы для работы с клиентами, товарами и заказами...


### 3. gui/main_window.py


import tkinter as tk
from tkinter import ttk, messagebox
from typing import Optional, Callable
from ..models.customer import Customer
from ..models.order import Order
from ..db.database import Database


class MainWindow:
    """Главное окно приложения для управления интернет-магазином."""

    def __init__(self, db: Database):
        """Инициализация главного окна.

        Parameters
        ----------
        db : Database
            Объект для работы с базой данных
        """
        self.db = db
        self.root = tk.Tk()
        self.root.title("Менеджер интернет-магазина")
        self.root.geometry("800x600")

        self._create_menu()
        self._create_main_frame()

    def _create_menu(self) -> None:
        """Создание меню приложения."""
        menubar = tk.Menu(self.root)

        # Меню "Файл"
        file_menu = tk.Menu(menubar, tearoff=0)
        file_menu.add_command(label="Экспорт в CSV...", command=self.export_to_csv)
        file_menu.add_command(label="Импорт из CSV...", command=self.import_from_csv)
        file_menu.add_separator()
        file_menu.add_command(label="Выход", command=self.root.quit)
        menubar.add_cascade(label="Файл", menu=file_menu)

        # Меню "Данные"
        data_menu = tk.Menu(menubar, tearoff=0)
        data_menu.add_command(label="Клиенты", command=self.show_customers)
        data_menu.add_command(label="Товары", command=self.show_products)
        data_menu.add_command(label="Заказы", command=self.show_orders)
        menubar.add_cascade(label="Данные", menu=data_menu)

        # Меню "Анализ"
        analysis_menu = tk.Menu(menubar, tearoff=0)
        analysis_menu.add_command(label="Динамика продаж", command=self.show_sales_dynamics)
        analysis_menu.add_command(label="Топ товары", command=self.show_top_products)
        analysis_menu.add_command(label="Топ клиенты", command=self.show_top_customers)
        menubar.add_cascade(label="Анализ", menu=analysis_menu)

        self.root.config(menu=menubar)

    def _create_main_frame(self) -> None:
        """Создание основного интерфейса."""
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill=tk.BOTH, expand=True)

        # Вкладка "Клиенты"
        self.customers_frame = ttk.Frame(self.notebook)
        self._setup_customers_tab()
        self.notebook.add(self.customers_frame, text="Клиенты")

        # Вкладка "Заказы"
        self.orders_frame = ttk.Frame(self.notebook)
        self._setup_orders_tab()
        self.notebook.add(self.orders_frame, text="Заказы")

        # Вкладка "Товары"
        self.products_frame = ttk.Frame(self.notebook)
        self._setup_products_tab()
        self.notebook.add(self.products_frame, text="Товары")

    def _setup_customers_tab(self) -> None:
        """Настройка вкладки для работы с клиентами."""
        # Панель инструментов
        toolbar = ttk.Frame(self.customers_frame)
        toolbar.pack(fill=tk.X, padx=5, pady=5)

        ttk.Button(toolbar, text="Добавить", command=self.add_customer).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="Редактировать", command=self.edit_customer).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="Удалить", command=self.delete_customer).pack(side=tk.LEFT)

        # Поиск
        search_frame = ttk.Frame(self.customers_frame)
        search_frame.pack(fill=tk.X, padx=5, pady=5)

        ttk.Label(search_frame, text="Поиск:").pack(side=tk.LEFT)
        self.customer_search_entry = ttk.Entry(search_frame)
        self.customer_search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        ttk.Button(search_frame, text="Найти", command=self.search_customers).pack(side=tk.LEFT)

        # Таблица клиентов
        columns = ("id", "name", "email", "phone", "address", "reg_date")
        self.customers_tree = ttk.Treeview(
            self.customers_frame, columns=columns, show="headings")

        for col in columns:
            self.customers_tree.heading(col, text=col.capitalize().replace("_", " "))
            self.customers_tree.column(col, width=100)

        self.customers_tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Заполнение таблицы данными
        self.load_customers()

    def load_customers(self) -> None:
        """Загрузка списка клиентов из базы данных."""
        # Очистка таблицы
        for item in self.customers_tree.get_children():
            self.customers_tree.delete(item)

        # Получение клиентов из базы данных (заглушка)
        customers = [
            (1, "Иванов Иван", "ivanov@example.com", "+79123456789", "Москва", "2023-01-15"),
            (2, "Петров Петр", "petrov@example.com", "+79234567890", "Санкт-Петербург", "2023-02-20")
        ]

        # Добавление клиентов в таблицу
        for customer in customers:
            self.customers_tree.insert("", tk.END, values=customer)

    def add_customer(self) -> None:
        """Открытие диалога добавления нового клиента."""
        dialog = CustomerDialog(self.root, self.db)
        self.root.wait_window(dialog.top)
        self.load_customers()

    # Другие методы интерфейса...

    def run(self) -> None:
        """Запуск главного цикла приложения."""
        self.root.mainloop()


class CustomerDialog:
    """Диалоговое окно для добавления/редактирования клиента."""

    def __init__(self, parent, db: Database, customer: Optional[Customer] = None):
        """Инициализация диалогового окна.

        Parameters
        ----------
        parent : tk.Toplevel
            Родительское окно
        db : Database
            Объект для работы с базой данных
        customer : Optional[Customer], optional
            Объект клиента для редактирования, по умолчанию None (новый клиент)
        """
        self.db = db
        self.customer = customer

        self.top = tk.Toplevel(parent)
        self.top.title("Добавить клиента" if customer is None else "Редактировать клиента")
        self.top.geometry("400x300")

        self._create_widgets()
        if customer is not None:
            self._fill_fields()

    def _create_widgets(self) -> None:
        """Создание элементов интерфейса."""
        # Поля формы
        ttk.Label(self.top, text="ФИО:").grid(row=0, column=0, padx=5, pady=5, sticky=tk.E)
        self.name_entry = ttk.Entry(self.top)
        self.name_entry.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W+tk.E)

        ttk.Label(self.top, text="Email:").grid(row=1, column=0, padx=5, pady=5, sticky=tk.E)
        self.email_entry = ttk.Entry(self.top)
        self.email_entry.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W+tk.E)

        ttk.Label(self.top, text="Телефон:").grid(row=2, column=0, padx=5, pady=5, sticky=tk.E)
        self.phone_entry = ttk.Entry(self.top)
        self.phone_entry.grid(row=2, column=1, padx=5, pady=5, sticky=tk.W+tk.E)

        ttk.Label(self.top, text="Адрес:").grid(row=3, column=0, padx=5, pady=5, sticky=tk.E)
        self.address_entry = ttk.Entry(self.top)
        self.address_entry.grid(row=3, column=1, padx=5, pady=5, sticky=tk.W+tk.E)

        # Кнопки
        button_frame = ttk.Frame(self.top)
        button_frame.grid(row=4, column=0, columnspan=2, pady=10)

        ttk.Button(button_frame, text="Сохранить", command=self.save_customer).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Отмена", command=self.top.destroy).pack(side=tk.LEFT, padx=5)

        # Настройка расширения колонок
        self.top.columnconfigure(1, weight=1)

    def _fill_fields(self) -> None:
        """Заполнение полей формы данными клиента."""
        self.name_entry.insert(0, self.customer.name)
        self.email_entry.insert(0, self.customer.email)
        self.phone_entry.insert(0, self.customer.phone)
        self.address_entry.insert(0, self.customer.address)

    def save_customer(self) -> None:
        """Сохранение клиента в базу данных."""
        try:
            customer_data = {
                'name': self.name_entry.get(),
                'email': self.email_entry.get(),
                'phone': self.phone_entry.get(),
                'address': self.address_entry.get()
            }

            if self.customer is None:
                # Добавление нового клиента
                customer = Customer(
                    customer_id=0,  # Временное значение, реальный ID присвоит БД
                    **customer_data
                )
                self.db.add_customer(customer)
            else:
                # Обновление существующего клиента
                self.customer.name = customer_data['name']
                self.customer.email = customer_data['email']
                self.customer.phone = customer_data['phone']
                self.customer.address = customer_data['address']
                self.db.update_customer(self.customer)

            self.top.destroy()
        except ValueError as e:
            messagebox.showerror("Ошибка", str(e))
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось сохранить клиента: {str(e)}")


### 4. analysis/visualizer.py


import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from typing import List, Dict, Any
from datetime import datetime
from ..models.order import Order


class DataVisualizer:
    """Класс для визуализации данных интернет-магазина."""

    @staticmethod
    def plot_sales_dynamics(orders: List[Order]) -> None:
        """Визуализация динамики продаж по датам.

        Parameters
        ----------
        orders : List[Order]
            Список заказов для анализа
        """
        # Преобразование данных в DataFrame
        df = pd.DataFrame([{
            'date': order.order_date.date(),
            'amount': order.total_amount
        } for order in orders])

        # Группировка по дате и суммирование суммы заказов
        df = df.groupby('date').sum().reset_index()

        # Создание графика
        plt.figure(figsize=(12, 6))
        sns.lineplot(data=df, x='date', y='amount', marker='o')
        plt.title('Динамика продаж по дням')
        plt.xlabel('Дата')
        plt.ylabel('Сумма продаж')
        plt.grid(True)
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.show()

    @staticmethod
    def plot_top_products(products: List[Dict[str, Any]], top_n: int = 5) -> None:
        """Визуализация топ-N товаров по количеству продаж.

        Parameters
        ----------
        products : List[Dict[str, Any]]
            Список словарей с информацией о товарах и их продажах
        top_n : int, optional
            Количество товаров для отображения, по умолчанию 5
        """
        # Сортировка товаров по количеству продаж
        top_products = sorted(products, key=lambda x: x['sales'], reverse=True)[:top_n]

        # Создание графика
        plt.figure(figsize=(10, 6))
        sns.barplot(
            x='sales',
            y='name',
            data=pd.DataFrame(top_products),
            palette='viridis'
        )
        plt.title(f'Топ-{top_n} товаров по количеству продаж')
        plt.xlabel('Количество продаж')
        plt.ylabel('Товар')
        plt.tight_layout()
        plt.show()

    @staticmethod
    def plot_customer_geography(customers: List[Dict[str, Any]]) -> None:
        """Визуализация географии клиентов.

        Parameters
        ----------
        customers : List[Dict[str, Any]]
            Список словарей с информацией о клиентах и их местоположении
        """
        # Подготовка данных
        df = pd.DataFrame(customers)
        df['city'] = df['address'].apply(lambda x: x.split(',')[0].strip())
        city_counts = df['city'].value_counts().reset_index()
        city_counts.columns = ['city', 'count']

        # Создание графика
        plt.figure(figsize=(12, 6))
        if len(city_counts) > 10:
            # Для большого количества городов показываем топ-10
            city_counts = city_counts.head(10)
            plt.title('Топ-10 городов по количеству клиентов')
        else:
            plt.title('География клиентов')

        sns.barplot(
            x='count',
            y='city',
            data=city_counts,
            palette='rocket'
        )
        plt.xlabel('Количество клиентов')
        plt.ylabel('Город')
        plt.tight_layout()
        plt.show()
```

### 5. main.py

```python
from db.database import Database
from gui.main_window import MainWindow


def main():
    """Точка входа в приложение."""
    # Инициализация базы данных
    db = Database()

    # Создание и запуск главного окна
    app = MainWindow(db)
    app.run()


if __name__ == "__main__":
    main()
```

## Дополнительные компоненты

### Тесты (tests/test_models.py)

```python
import unittest
from datetime import datetime
from models.customer import Customer


class TestCustomer(unittest.TestCase):
    """Тесты для класса Customer."""

    def setUp(self):
        """Настройка тестового окружения."""
        self.valid_customer_data = {
            'customer_id': 1,
            'name': 'Иван Иванов',
            'email': 'ivanov@example.com',
            'phone': '+79123456789',
            'address': 'Москва',
            'registration_date': datetime.now()
        }

    def test_valid_customer_creation(self):
        """Тест создания объекта Customer с валидными данными."""
        customer = Customer(**self.valid_customer_data)
        self.assertEqual(customer.name, self.valid_customer_data['name'])
        self.assertEqual(customer.email, self.valid_customer_data['email'])

    def test_invalid_email_validation(self):
        """Тест валидации некорректного email."""
        invalid_data = self.valid_customer_data.copy()
        invalid_data['email'] = 'invalid-email'

        with self.assertRaises(ValueError):
            Customer(**invalid_data)

    def test_invalid_phone_validation(self):
        """Тест валидации некорректного номера телефона."""
        invalid_data = self.valid_customer_data.copy()
        invalid_data['phone'] = '12345'

        with self.assertRaises(ValueError):
            Customer(**invalid_data)

    def test_to_dict_method(self):
        """Тест преобразования объекта Customer в словарь."""
        customer = Customer(**self.valid_customer_data)
        customer_dict = customer.to_dict()

        self.assertIsInstance(customer_dict, dict)
        self.assertEqual(customer_dict['name'], self.valid_customer_data['name'])
        self.assertIn('registration_date', customer_dict)

    def test_from_dict_method(self):
        """Тест создания объекта Customer из словаря."""
        customer_dict = {
            'customer_id': 2,
            'name': 'Петр Петров',
            'email': 'petrov@example.com',
            'phone': '+79234567890',
            'address': 'Санкт-Петербург',
            'registration_date': '2023-01-15T12:00:00'
        }

        customer = Customer.from_dict(customer_dict)
        self.assertEqual(customer.name, customer_dict['name'])
        self.assertEqual(customer.email, customer_dict['email'])


if __name__ == '__main__':
    unittest.main()
```

### Валидация (utils/validators.py)

```python
import re
from typing import Optional


def validate_email(email: str) -> bool:
    """Проверка валидности email адреса.

    Parameters
    ----------
    email : str
        Email адрес для проверки

    Returns
    -------
    bool
        True если email валиден, иначе False
    """
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None


def validate_phone(phone: str) -> bool:
    """Проверка валидности номера телефона.

    Parameters
    ----------
    phone : str
        Номер телефона для проверки

    Returns
    -------
    bool
        True если номер телефона валиден, иначе False
    """
    pattern = r'^\+?[1-9]\d{1,14}$'  # E.164 format
    return re.match(pattern, phone) is not None


def validate_date(date_str: str, fmt: str = '%Y-%m-%d') -> bool:
    """Проверка валидности даты в заданном формате.

    Parameters
    ----------
    date_str : str
        Строка с датой для проверки
    fmt : str, optional
        Формат даты, по умолчанию '%Y-%m-%d'

    Returns
    -------
    bool
        True если дата валидна, иначе False
    """
    try:
        from datetime import datetime
        datetime.strptime(date_str, fmt)
        return True
    except ValueError:
        return False

CREATE TABLE clients (
	client_id SERIAL,
	first_name TEXT,
	last_name TEXT,
	phone TEXT,
	email TEXT
);

SELECT * FROM hr.clients;

SELECT
	first_name, last_name
FROM
	hr.clients
-- ORDER BY first_name
LIMIT 1;


INSERT INTO hr.clients
	(first_name, last_name, phone, email)
VALUES
	('Romanov', 'Sergey', '89033885687', 'sergeyrpython@gmail.com'),
	('Ivanov', 'Roman', '89991245231', 'ivanov@mail.ru');


-- Изменение записей
UPDATE